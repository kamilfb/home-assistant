- id: "1022226654411"
  alias: Air Conditioning - Follow Tado settings
  description: "Follows on/off state plus temperature target from Ground Floor Tado"
  trigger:
    - platform: state
      entity_id:
        - climate.ground_floor
      attribute: temperature
    - platform: state
      entity_id:
        - climate.ground_floor
  condition: []
  action:
  - service: input_number.set_value
    data_template:
      entity_id: input_number.ground_floor_temp_target
      value: >
        {% set gfTempTarget  = state_attr('climate.ground_floor', 'temperature')|float %}
        {{ gfTempTarget }}
  - service: input_select.select_option
    target:
      entity_id: input_select.living_room_hvac_mode
    data:
      option: "{{ 'off' if (states('climate.ground_floor') == 'off') else 'heat' }}"
    
  mode: single

- id: "1022226657321"
  alias: Air Conditioning - Adjust target temperature
  description: "Adjusts the target temperature to keep it between the configured range (~21.0/21.5)"
  trigger:
  - platform: time_pattern
    minutes: "/2"
  - platform: state
    entity_id:
    - input_number.ground_floor_temp_target
    - input_number.ground_floor_temp_target_margin
    - input_number.ground_floor_temp_target_min_cycle_duration
    for:
      hours: 0
      minutes: 0
      seconds: 30
  condition: 
  - condition: time
    after: "06:30:00"
    before: "21:00:00"
  - condition: template
    value_template: >-
      {{ states('climate.lounge') == 'heat' }}
  action:
  - service: input_number.set_value
    data_template:
      entity_id: input_number.living_room_temp_target
      value: >
        {% set gfTempTarget  = state_attr('climate.lounge', 'temperature')|float %}
        {% set gfTemp        = states('sensor.ground_floor_temperature')|float %}
        {% set gfTempAvg     = states('sensor.ground_floor_temperature_30min_average')|float %}
        {# Negative "gf30minDelta" means temp is dropping #}
        {% set gf30minDelta  = gfTemp - gfTempAvg %}
        {% set manualTempTarget = states('input_number.ground_floor_temp_target')|float %}
        {% set manualTempMargin = states('input_number.ground_floor_temp_target_margin')|float %}
        {% set manualTempCycle  = states('input_number.ground_floor_temp_target_min_cycle_duration')|int %}
        {% set lowTarget        = manualTempTarget - manualTempMargin %}
        {% set highTarget       = manualTempTarget + manualTempMargin %}
        {# Avoid short cycling (after start-up, manual change or auto-adjustment) #}
        {% set targetlastChanged = (as_timestamp(now()) - as_timestamp(states.input_number.living_room_temp_target.last_changed)|int)/60 %}
        {% set statuslastChanged = (as_timestamp(now()) - as_timestamp(states.climate.lounge.last_changed)|int)/60 %}
        {% set canAdjust = true if (targetlastChanged > manualTempCycle and statuslastChanged > manualTempCycle) else false %}
        {% set tempTarget = gfTempTarget %}
        {# Change the target if either outside of the temperature brackets already, or expecting this with the delta applied #}
        {# In rare scenarios when the temp is rising fast, if alread seeing double the high target allow reducing temp in half the cycle time #}
        {% set tempTarget = tempTarget + 0.5 if ((gfTemp <= lowTarget  or gfTemp + gf30minDelta <= lowTarget)  and canAdjust) else tempTarget %}
        {% set tempTarget = tempTarget - 0.5 if ((gfTemp >= highTarget or gfTemp + gf30minDelta >= highTarget) and canAdjust) 
                                             or ((gfTemp + gf30minDelta >= highTarget + manualTempMargin) and targetlastChanged > manualTempCycle/2) else tempTarget %}
        {{ tempTarget }}
#  - service: climate.set_temperature
#    data_template:
#      entity_id: climate.lounge
#      temperature: "{{ states('input_number.living_room_temp_target') }}"
  mode: single

- id: "1022226653322"
  alias: Air Conditioning - Update living room target temp
  description: "Adjusts the target temperature of the living room unit"
  trigger:
  - platform: state
    entity_id:
    - input_number.living_room_temp_target
    for:
      hours: 0
      minutes: 0
      seconds: 15
  action:
  - service: climate.set_temperature
    data_template:
      entity_id: climate.lounge
      temperature: "{{ states('input_number.living_room_temp_target') }}"
  mode: single

- id: "1022226653399"
  alias: Air Conditioning - Update on/off state
  description: "Adjusts the on/off state of the living room unit"
  trigger:
  - platform: state
    entity_id:
    - input_select.living_room_hvac_mode
    for:
      hours: 0
      minutes: 0
      seconds: 15
  action:
  - service: climate.set_hvac_mode
    data_template:
      entity_id: climate.lounge
      hvac_mode: "{{ states('input_select.living_room_hvac_mode') }}"
  mode: single

- id: '12233445566789'
  alias: Sinks - Hot Water - Set immersion target level
  description: Set target immersion target heating level based on anticipated solar production
  trigger:
  - platform: time
    at: "22:45:00"
  - platform: time
    at: "23:45:00"  
  condition: []
  action:
  - service: input_number.set_value
    data_template:
      entity_id: input_number.night_immersion_target
      # Assumptions: 2.5kWh/h for 4hrs (10min pause), can use 2.5kWh for every 5kWh generated above 15kWh (to cater for weather fluctuation)
      #              total capacity of the 210L tank is about 15kWh (from 5 to 65C)
      #              at 5C outside, on average it could take 7.5kWh per night to heat to max, 
      #              also daily average (night+day) was 7.5kWh so target shouldn't be more than 8kWh, minimum to up of 3kWh
      #              end of night tariff 04:30am
      # Note: instead of using separate tomorrow/today's forecasts, use a single state (energy_production_upcoming) and then its average over a few hours (filtered)
      # Note: simple weather compensation adding kWh to target (+2 for below -3C, +1 for below 2C, -1 for above 12C, -2 for above 17C)
      # Note: if todays solar top up was low, ignore upcoming forecast and heat to max
      value: >
        {% set solar = states('sensor.filtered_upcoming_solar_forecast') %}
        {% set todaysSolarTopUp = states('sensor.daily_hot_water_peak')|float %}
        {% set currentTemperature = state_attr('weather.forecast_home', 'temperature') %}
        {% set min_immersion = states('input_number.night_min_immersion_target')|float %}
        {% set weatherAdjustment = 0 %} 
        {% if is_number(currentTemperature) %}
          {% set weatherAdjustment =  2 if (currentTemperature|float                                   <= -3) else weatherAdjustment %}
          {% set weatherAdjustment =  1 if (currentTemperature|float > -3 and currentTemperature|float <=  2) else weatherAdjustment %}
          {% set weatherAdjustment =  0 if (currentTemperature|float >  2 and currentTemperature|float <= 12) else weatherAdjustment %}
          {% set weatherAdjustment = -1 if (currentTemperature|float > 12 and currentTemperature|float <= 17) else weatherAdjustment %}
          {% set weatherAdjustment = -2 if (currentTemperature|float > 17)                                    else weatherAdjustment %}
        {% endif %} 
        {% set solarThreshold = 15 %} 
        {% set target = 8 + weatherAdjustment %} 
        {% if is_number(solar) %}
          {% set target = target - ((solar|float - solarThreshold)*2.5/5)|round(1) if (solar|float >  solarThreshold and todaysSolarTopUp > 2.5) else target %}          
        {% endif %} 
        {{ target if (target > min_immersion) else min_immersion }}
  - delay:
      hours: 0
      minutes: 0
      seconds: 5
      milliseconds: 0
  - service: input_number.set_value
    data_template:
      entity_id: input_number.max_temp_idle_seconds
      # Allow high idle time when target is high (super hot water), low in case high solar forecast (not so hot water)
      value: >
        {% set immersion = states('input_number.night_immersion_target') %}
        {% set target = 180 %} 
        {% if is_number(immersion) %}
          {% set target =  30 if (immersion|float <= 2) else target %}  
          {% set target =  60 if (immersion|float >  2 and immersion|float <= 3) else target %}
          {% set target =  90 if (immersion|float >  3 and immersion|float <= 4) else target %}
          {% set target = 120 if (immersion|float >  4 and immersion|float <= 5) else target %}
          {% set target = 150 if (immersion|float >  5 and immersion|float <= 6) else target %}
          {% set target = 180 if (immersion|float >  6 and immersion|float <= 7) else target %}
          {% set target = 240 if (immersion|float >  7 and immersion|float <  8) else target %}
          {% set target = 300 if (immersion|float >= 8) else target %}          
        {% endif %} 
        {{ target }}
  mode: single

- id: '1395837280000'
  alias: Battery - Set solar battery target level
  description: Set target battery level (charge from grid) based on anticipated solar production
  trigger:
  - platform: time
    at: "23:30:00"
  # If the forecast charges for worse, a last change to top up the battery  
  - platform: time
    at: "03:30:00"  
  - platform: state
    entity_id:
    - input_number.min_battery_target
    - input_number.max_battery_target
    for:
      hours: 0
      minutes: 0
      seconds: 30
  condition: []
  action:
  - repeat:
      sequence:
      - service: input_number.set_value
        data_template:
          entity_id: input_number.new_battery_target
          # Assumptions: hourly morning usage of 0.25kWh/h, battery capacity 6.2kWh, end of night tariff 04:30am, overcharging by 4-5% hence -4 of the target
          # Assumptions: low solar range upped to cater for immersion top up (2kWh)
          # Assumptions: 0.9kWh for heating per hour (heating from 0430 to 0630)
          # Note: min target should be about 22% winter and 14% in summer
          # Note: instead of using separate tomorrow/today's forecasts, use a single state (energy_production_upcoming) and then its average over a few hours (filtered)
          value: >
            {% set min_battery_target = states('input_number.min_battery_target')|int %}
            {% set max_battery_target = states('input_number.max_battery_target')|int %}
            {% set solar = states('sensor.filtered_upcoming_solar_forecast') %}
            {% set morningHourlyLoad = 0.25 %}
            {% set morningHourlyHeating = 0.9 %}
            {% set secondsToSunRising = (today_at(as_timestamp(states.sun.sun.attributes.next_rising)| timestamp_custom("%H:%M")) - today_at('04:30')).seconds %}
            {% set morningDemandKWh = (secondsToSunRising/60/60*morningHourlyLoad + morningHourlyHeating*2.5)|round %}
            {% set morningDemand = (morningDemandKWh/6.2*100)|round %}
            {% set minTarget = 10 + morningDemand - 4 %}
            {% if is_number(solar) %}
              {% set target = max_battery_target  if (solar|float <= 5) else target %}  
              {% set target = minTarget + 60 if (solar|float >  5 and solar|float <=  6) else target %}
              {% set target = minTarget + 40 if (solar|float >  6 and solar|float <=  7) else target %}
              {% set target = minTarget + 25 if (solar|float >  7 and solar|float <=  8) else target %}
              {% set target = minTarget + 15 if (solar|float >  8 and solar|float <=  9) else target %}
              {% set target = minTarget + 10 if (solar|float >  9 and solar|float <= 10) else target %}
              {% set target = minTarget +  5 if (solar|float > 10 and solar|float <= 11) else target %}
              {% set target = minTarget      if (solar|float > 11) else target %}
            {% endif %} 
            {% set target = target if (target > min_battery_target) else min_battery_target %} 
            {{ target if (target <= max_battery_target) else max_battery_target }}
      - service: rest_command.solax_local_set_charge_battery_from_grid
        data:
          # Max level to 92% to reduce battery wear. Minimum to 11% plus 4% overcharge
          level: >
            {{ states('input_number.new_battery_target') }}
      - delay:
          hours: 0
          minutes: 0
          seconds: 10
          milliseconds: 0
      - service: homeassistant.update_entity
        entity_id: sensor.solax_rest_local_settings

      until:
      - condition: template
        # Try up to 3 times if the updated setting doen't reflect the target
        value_template: >-
            {{ states('sensor.solax_local_battery_charge_from_grid_to')|int == states('input_number.new_battery_target')|int or
                repeat.index == 3 }}
  mode: single

- id: '1105783920393'
  alias: Sinks - Hot Water - Start immersion heater (excess solar)
  description: ''
  trigger:
  - platform: state
    entity_id: binary_sensor.request_3kw_immersion
    for:
      hours: 0
      minutes: 1
      seconds: 0
    to: "on"    
  condition: 
  - condition: time
    after: "06:30:00"
    before: "19:30:00"   
  action:
  - repeat:
      sequence:
      - type: turn_on
        device_id: 0e56664e1317e879ea8852efe217d98b
        entity_id: switch.sonoff_100168acb6
        domain: switch
      - delay:
          hours: 0
          minutes: 0
          seconds: 15
      until:
      - condition: template
        # Try up to 3 times if the updated setting doen't reflect the target
        value_template: >-
            {{ states('switch.sonoff_100168acb6') == 'on' or repeat.index == 3 }}
  mode: single

- id: '11001293920394'
  alias: Sinks - Hot Water - Run immersion heater (evening top-up in case of low solar)
  description: ''
  trigger:
  - platform: time
    at: "19:35:00" 
  condition:
  - condition: template
    # Only turn on immersion if usage so far is less than the target
    value_template: >-
      {{ states('sensor.daily_hot_water_peak')|float + states('sensor.daily_hot_water_solar')|float < states('input_number.evening_immersion_target')|float }}
  action:
  - repeat:
      sequence:
      - type: turn_on
        device_id: 0e56664e1317e879ea8852efe217d98b
        entity_id: switch.sonoff_100168acb6
        domain: switch
      - delay:
          hours: 0
          minutes: 0
          seconds: 15
      until:
      - condition: template
        # Try up to 3 times if the updated setting doen't reflect the target
        value_template: >-
            {{ states('switch.sonoff_100168acb6') == 'on' or repeat.index == 3 }}
  - repeat:
      sequence:
      - delay:
          hours: 0
          minutes: 1
          seconds: 0
      until:
      - condition: template
        # Keep it in on state until at least 1kWh 
        value_template: >-
            {{ states('sensor.daily_hot_water_peak')|float + states('sensor.daily_hot_water_solar')|float >= states('input_number.evening_immersion_target')|float }}
  - repeat:
      sequence:
      - type: turn_off
        device_id: 0e56664e1317e879ea8852efe217d98b
        entity_id: switch.sonoff_100168acb6
        domain: switch
      - delay:
          hours: 0
          minutes: 0
          seconds: 15
          milliseconds: 0
      until:
      - condition: template
        # Try up to 3 times if the updated setting doen't reflect the target
        value_template: >-
            {{ states('switch.sonoff_100168acb6') == 'off' or repeat.index == 3 }}
  mode: single

- id: '1105783920394'
  alias: Sinks - Hot Water - Start immersion heater (night start)
  description: ''
  trigger:
  - platform: time
    at: "00:35:00"
  - platform: time
    at: "01:35:00"      
  - platform: time
    at: "02:35:00"  
  - platform: time
    at: "03:35:00"   
  condition:
  - condition: template
    # Only turn on immersion if usage so far is less than the target
    value_template: >-
      {{ states('sensor.daily_hot_water_offpeak')|float < states('input_number.night_immersion_target')|float }}
  action:
  - repeat:
      sequence:
      - type: turn_on
        device_id: 0e56664e1317e879ea8852efe217d98b
        entity_id: switch.sonoff_100168acb6
        domain: switch
      - delay:
          hours: 0
          minutes: 0
          seconds: 15
      until:
      - condition: template
        # Try up to 3 times if the updated setting doen't reflect the target
        value_template: >-
            {{ states('switch.sonoff_100168acb6') == 'on' or repeat.index == 3 }}
  mode: single

- id: '1029486719232'
  alias: Sinks - Hot Water - Stop immersion heater (max temp idle time or night target reached)
  description: Turn off completely if thermostat starts turning off the heating (hot enough) or target achieved
  trigger:
  - platform: numeric_state
    entity_id: sensor.sonoff_100168acb6_power
    for:
      seconds: "{{ states('input_number.max_temp_idle_seconds')|int }}"
    below: 1000
  - platform: template
    value_template: >-
      {{ states('sensor.daily_hot_water_offpeak')|float >= states('input_number.night_immersion_target')|float }}
  condition: 
  - condition: time
    after: "00:30:00"
    before: "04:30:00"    
  action:
  - repeat:
      sequence:
      - type: turn_off
        device_id: 0e56664e1317e879ea8852efe217d98b
        entity_id: switch.sonoff_100168acb6
        domain: switch
      - delay:
          hours: 0
          minutes: 0
          seconds: 15
          milliseconds: 0
      until:
      - condition: template
        # Try up to 3 times if the updated setting doen't reflect the target
        value_template: >-
            {{ states('switch.sonoff_100168acb6') == 'off' or repeat.index == 3 }}
  mode: single

- id: '1283957837432'
  alias: Sinks - Hot Water - Stop immersion heater (low solar or night end)
  description: ''
  trigger:
  - platform: state
    entity_id: binary_sensor.request_3kw_immersion
    for:
      hours: 0
      minutes: 0
      seconds: 30
    to: "off"
  - platform: time
    at: "01:25:00"      
  - platform: time
    at: "02:25:00"         
  - platform: time
    at: "03:25:00"       
  - platform: time
    at: "04:25:00"    
  action:
  - repeat:
      sequence:
      - type: turn_off
        device_id: 0e56664e1317e879ea8852efe217d98b
        entity_id: switch.sonoff_100168acb6
        domain: switch
      - delay:
          hours: 0
          minutes: 0
          seconds: 15
      until:
      - condition: template
        # Try up to 3 times if the updated setting doen't reflect the target
        value_template: >-
            {{ states('switch.sonoff_100168acb6') == 'off' or repeat.index == 3 }}
  mode: single

# Always reset to the same state - i.e. no off-peak forced charging overnight
- id: "1143938438939"
  alias: Battery - Disable forced charge
  description: "Allows for discharge if too much energy stored from previous day (default state)"
  trigger:
  - platform: time
    at: "23:40:00"  
  - platform: time
    at: "23:50:00"
  action:
  - repeat:
      sequence:
#      - service: rest_command.solax_local_set_period2_enable
#        data:
#          # 1 = enabled, 0 = disabled
#          enabled: >
#            {{ 0 }}
      - service: rest_command.solax_local_set_forced_charge_start
        data:
          value: >
            {{ 4 + 25 * 256 }}
      - delay:
          hours: 0
          minutes: 0
          seconds: 15
          milliseconds: 0
      - service: homeassistant.update_entity
        entity_id: sensor.solax_rest_local_settings

      until:
      - condition: template
        # Try up to 3 times if the updated setting doen't reflect the target
        # {{ states('sensor.solax_local_battery_chd2_enabled')|int == 0 or repeat.index == 3 }}
        value_template: >-
            {{ states('sensor.solax_local_battery_setting_start_charge') == '04:25' or repeat.index == 3 }}
  mode: single

# Detect if battery needs topping up within the off-peak tariff or if discharge should stop and the remainder power be left for peak usage 
# (+4 is how much the inverter overshoots the target charge, +4 is buffer in case of fast discharge)
- id: "1029376657476"
  alias: Battery - Enable forced charge
  description: "Stops allowed discharge and allows for charging to target"
  trigger:
  - platform: time_pattern
    minutes: "/1"
  condition: 
  - condition: time
    after: "00:25:00"
    before: "04:20:00"
#  - condition: template
#    value_template: >-
#      {{ states('sensor.solax_local_battery_chd2_enabled')|int == 0 }}
  - condition: template
    value_template: >-
      {{ states('sensor.solax_local_battery_soc')|int <= states('sensor.solax_local_battery_charge_from_grid_to')|int + 8 }}
  action:
  - repeat:
      sequence:
#      - service: rest_command.solax_local_set_period2_enable
#        data:
#          # 1 = enabled, 0 = disabled
#          enabled: >
#            {{ 1 }}
      - service: rest_command.solax_local_set_forced_charge_start
        data:
          value: >
            {{ 0 + 35 * 256 }}            
      - delay:
          hours: 0
          minutes: 0
          seconds: 15
          milliseconds: 0
      - service: homeassistant.update_entity
        entity_id: sensor.solax_rest_local_settings

      until:
      - condition: template
        # Try up to 3 times if the updated setting doen't reflect the target
        # {{ states('sensor.solax_local_battery_chd2_enabled')|int == 1 or repeat.index == 3 }}
        value_template: >-
            {{ states('sensor.solax_local_battery_setting_start_charge') == '00:35' or repeat.index == 3 }}
  mode: single

- id: "1302984839333"
  alias: Tariffs - Set 'solar' tariff for tracking usage from PV
  description: "Set some meters to use 'solar' tariff"
  trigger:
  - platform: sun
    event: sunrise
    offset: 0
    variables:
      tariff: solar
  - platform: sun
    event: sunset
    offset: 0
    variables:
      tariff: peak
  condition: []
  action:     
  - service: select.select_option
    target:
      entity_id: select.monthly_hot_water
    data:
      option: "{{ tariff }}"
  - service: select.select_option
    target:
      entity_id: select.daily_hot_water
    data:
      option: "{{ tariff }}"

- id: "1302984839203"
  alias: Tariffs - Switch electricity tariff
  description: "Set electricity tariff for utility sensor"
  trigger:
  - platform: time
    at: "00:30:00"
    variables:
      tariff: offpeak
  - platform: time
    at: "04:30:00"
    variables:
      tariff: peak
  condition: []
  action:
  - service: select.select_option
    target:
      entity_id: select.daily_grid
    data:
      option: "{{ tariff }}"
  - service: select.select_option
    target:
      entity_id: select.monthly_grid
    data:
      option: "{{ tariff }}"      
  - service: select.select_option
    target:
      entity_id: select.monthly_hot_water
    data:
      option: "{{ tariff }}"
  - service: select.select_option
    target:
      entity_id: select.daily_hot_water
    data:
      option: "{{ tariff }}"
  - service: input_number.set_value
    target:
      entity_id: input_number.electricity_tariff_cost
    data:
      value: >
        {% set cost = dict(peak=0.41, offpeak=0.12) %}
        {{ cost[tariff] }}
  mode: single

# Keep refreshing the energy readings for manual inspection and more snappy automations
- id: "1019847854392"
  alias: Inverter - Refresh local energy readings
  description: "Updates local inverter readings"
  trigger:
  - platform: time_pattern
    seconds: "/10"
  condition: 
  - condition: time
    after: "06:00:00"
    before: "22:00:00"
  action:
  - service: homeassistant.update_entity
    entity_id: sensor.solax_rest_local
  mode: single
